// File: AetherDriftCore.cs
// A compact Unity prototype implementing core systems for "Aether Drift: Echoes of the Glass Labyrinth".
// Contains: ShardController (Phase-Shift), PrismKey, Projector, LabyrinthManager (geometry change),
// Sentinel (enemy vulnerability), EchoMemory (collection).
//
// Drop into an empty Unity project (one file). Attach components as indicated in comments.

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

#region Shard (player) and Phase-Shift
public class ShardController : MonoBehaviour
{
    public static ShardController Instance { get; private set; }

    [Header("Phase-Shift")]
    public float phaseDuration = 3f;
    public float phaseCooldown = 2f;
    public Material aetherMaterial;      // Optional: set a glow/ghost material
    public Material normalMaterial;      // Optional: original material for quick swap
    public KeyCode phaseKey = KeyCode.Space;

    bool isPhased = false;
    bool canPhase = true;
    Renderer[] renderers;
    Collider[] colliders;

    void Awake()
    {
        Instance = this;
        renderers = GetComponentsInChildren<Renderer>();
        colliders = GetComponentsInChildren<Collider>();
    }

    void Update()
    {
        if (Input.GetKeyDown(phaseKey) && canPhase)
            StartCoroutine(PhaseRoutine());
    }

    IEnumerator PhaseRoutine()
    {
        canPhase = false;
        BeginPhase();
        yield return new WaitForSeconds(phaseDuration);
        EndPhase();

        yield return new WaitForSeconds(phaseCooldown);
        canPhase = true;
    }

    void BeginPhase()
    {
        isPhased = true;
        // Visual: swap materials if provided
        if (aetherMaterial != null)
            foreach (var r in renderers)
                r.material = aetherMaterial;

        // Physics: make colliders triggers so we can pass through geometry designed to block normal world
        foreach (var c in colliders)
            c.isTrigger = true;

        // Notify others (e.g., enemies)
        SendMessageToPhaseListeners(true);
    }

    void EndPhase()
    {
        isPhased = false;
        if (normalMaterial != null)
            foreach (var r in renderers)
                r.material = normalMaterial;

        foreach (var c in colliders)
            c.isTrigger = false;

        SendMessageToPhaseListeners(false);
    }

    void SendMessageToPhaseListeners(bool phased)
    {
        // Simple broadcast; enemies or other objects can implement OnPhaseChanged(bool)
        foreach (var listener in FindObjectsOfType<MonoBehaviour>())
        {
            // Using SendMessage is slower but straightforward for prototype
            listener.SendMessage("OnPhaseChanged", phased, SendMessageOptions.DontRequireReceiver);
        }
    }

    public bool IsPhased() => isPhased;
}
#endregion

#region LabyrinthManager and Geometry Changes
public class LabyrinthManager : MonoBehaviour
{
    public static LabyrinthManager Instance { get; private set; }

    [Tooltip("Assign sets of transforms that can be manipulated when projectors activate.")]
    public List<GeometrySet> geometrySets = new List<GeometrySet>();

    void Awake() => Instance = this;

    // Called by Projector when a PrismKey is slotted
    public void ApplyPrismKey(int prismId)
    {
        StartCoroutine(ApplyPrismCoroutine(prismId));
    }

    IEnumerator ApplyPrismCoroutine(int prismId)
    {
        // Find matching geometry set
        var set = geometrySets.Find(s => s.prismId == prismId);
        if (set == null)
        {
            Debug.LogWarning($"No geometry set found for prism {prismId}");
            yield break;
        }

        // Optional pre-visualization (holographic projector)
        if (set.projectorHologram != null)
            set.projectorHologram.SetActive(true);

        float t = 0f;
        while (t < set.duration)
        {
            t += Time.deltaTime;
            float p = set.curve.Evaluate(Mathf.Clamp01(t / set.duration));
            for (int i = 0; i < set.targets.Length; i++)
            {
                var target = set.targets[i];
                if (target == null) continue;
                // Interpolate position and rotation towards the defined goal
                target.localPosition = Vector3.Lerp(set.origPositions[i], set.goalPositions[i], p);
                target.localRotation = Quaternion.Slerp(set.origRotations[i], set.goalRotations[i], p);
            }
            yield return null;
        }

        // Toggle final state (some projectors may toggle)
        if (set.toggleAfterApply)
            set.applied = !set.applied;

        if (set.projectorHologram != null)
            set.projectorHologram.SetActive(false);

        // Notify possible echoes or gameplay systems
        SendPostApplySignals(prismId);
    }

    void SendPostApplySignals(int prismId)
    {
        // Broadcast a simple message; systems can respond to geometry changes
        foreach (var mb in FindObjectsOfType<MonoBehaviour>())
            mb.SendMessage("OnPrismApplied", prismId, SendMessageOptions.DontRequireReceiver);
    }
}

[System.Serializable]
public class GeometrySet
{
    public int prismId = 0;
    public Transform[] targets;
    public Vector3[] goalPositions;
    public Quaternion[] goalRotations;
    [HideInInspector] public Vector3[] origPositions;
    [HideInInspector] public Quaternion[] origRotations;
    public float duration = 1.5f;
    public AnimationCurve curve = AnimationCurve.EaseInOut(0, 0, 1, 1);
    public GameObject projectorHologram;
    public bool toggleAfterApply = false;
    [HideInInspector] public bool applied = false;

    // Helper to cache original transforms (call from editor or Start)
    public void CacheOriginals()
    {
        if (targets == null) return;
        int n = targets.Length;
        origPositions = new Vector3[n];
        origRotations = new Quaternion[n];
        for (int i = 0; i < n; i++)
        {
            if (targets[i] != null)
            {
                origPositions[i] = targets[i].localPosition;
                origRotations[i] = targets[i].localRotation;
            }
        }
    }
}
#endregion

#region PrismKey and Projector
public class PrismKey : MonoBehaviour
{
    public int prismId = 0;
    public string displayName = "Prism Key";

    // Called when inserted into a Projector (triggered by Projector)
    public void OnInserted(Projector proj)
    {
        // Could play sound/animation then notify LabyrinthManager
        LabyrinthManager.Instance.ApplyPrismKey(prismId);
        // Destroy or disable the key
        gameObject.SetActive(false);
    }
}

public class Projector : MonoBehaviour
{
    public int requiredPrismId = 0;
    public KeyCode interactKey = KeyCode.E;
    public Transform insertPoint;

    bool hasKeyNearby = false;
    PrismKey nearbyKey = null;

    void Update()
    {
        if (hasKeyNearby && nearbyKey != null && Input.GetKeyDown(interactKey))
        {
            InsertKey(nearbyKey);
        }
    }

    void InsertKey(PrismKey key)
    {
        if (key.prismId != requiredPrismId)
        {
            // Could flash denial effect
            Debug.Log("Wrong Prism");
            return;
        }

        // Snap key to projector
        if (insertPoint != null)
        {
            key.transform.position = insertPoint.position;
            key.transform.rotation = insertPoint.rotation;
            key.transform.SetParent(insertPoint);
        }

        key.OnInserted(this);
        // Optionally change projector visuals
        SendMessage("OnKeyInserted", key.prismId, SendMessageOptions.DontRequireReceiver);
    }

    void OnTriggerEnter(Collider other)
    {
        var key = other.GetComponent<PrismKey>();
        if (key != null)
        {
            hasKeyNearby = true;
            nearbyKey = key;
        }
    }

    void OnTriggerExit(Collider other)
    {
        var key = other.GetComponent<PrismKey>();
        if (key != null && nearbyKey == key)
        {
            hasKeyNearby = false;
            nearbyKey = null;
        }
    }
}
#endregion

#region Sentinels (enemies) and puzzle echoes
public class Sentinel : MonoBehaviour
{
    public int maxHealth = 3;
    int health;
    public bool vulnerableOnlyWhenPhased = true;
    public ParticleSystem shatterEffect;

    void Start() => health = maxHealth;

    public void ReceiveAttack(int damage)
    {
        bool shardPhased = ShardController.Instance != null && ShardController.Instance.IsPhased();
        if (vulnerableOnlyWhenPhased && !shardPhased)
        {
            // Attack has no effect or is reflected
            FlashShield();
            return;
        }

        health -= damage;
        if (health <= 0) Die();
    }

    void FlashShield()
    {
        // Simple visual feedback
        // (implement shader flash or particle in editor)
    }

    void Die()
    {
        if (shatterEffect != null) Instantiate(shatterEffect, transform.position, Quaternion.identity);
        Destroy(gameObject);
    }

    // Optional listener for phase changes
    void OnPhaseChanged(bool phased)
    {
        // Example: change tint or behavior
        var r = GetComponent<Renderer>();
        if (r != null)
            r.material.SetFloat("_Emission", phased ? 1f : 0.2f);
    }
}
#endregion

#region EchoMemory (collectible fragments)
public class EchoMemory : MonoBehaviour
{
    public string fragmentText = "Fragment of memory...";
    bool collected = false;

    void OnTriggerEnter(Collider other)
    {
        if (collected) return;
        if (other.GetComponent<ShardController>())
        {
            Collect();
        }
    }

    void Collect()
    {
        collected = true;
        // Could push to a UI manager or story log
        Debug.Log("Collected Echo: " + fragmentText);
        gameObject.SetActive(false);
    }
}
#endregion